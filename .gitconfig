# vim:tw=0:ts=2:sw=2:et:norl:ft=gitconfig
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/landonb/git-smart#💡
# License: MIT

# #######################################################################
# ***                            Overview                             ***
# #######################################################################

# USAGE: Read through the [alias]es defined below for a description of each.

# YOU/DEV: Put your user.* settings, private aliases, and whatever else you
# want in a separate, private config file, named .gitconfig.local, that's
# loaded last (at the end of this file, so it overrides anything herein).

# CONVENTION: Some commands work on branch(es) and remote(s) and will default
#             to the following unless you pass args indicating otherwise
#             (or unless the command otherwise deduces the remote name,
#             e.g., by using the remote indicated by the tracking branch).
#
# - Remote names:
#
#   'origin'      The default remote name assigned by `git clone`.
#                 Herein assumed to refer to repositories you control,
#                 e.g., if you fork a project, "origin" points to your
#                 fork on, say, GitHub. Or if you create a new project,
#                 "origin" refers to it.
#   'upstream'    The remote name used for the main project repository,
#                 e.g., if you fork a project, the "upstream" remote
#                 points to the main project repository. The name,
#                 "upstream", is not codified by any tools, GitHub,
#                 etc., it's just what I've seen used a lot in online
#                 document/blog posts/Q&As, so I think it's well-known.
#
#   'proving'     What I (lb) like to use instead of "origin", as in,
#                 where I prove my forked code works before submitting
#                 a pull request to the upstream project team.
#   'release'     What I (lb) prefer to use instead of "upstream", as
#                 in, the "release" remote points to the main project
#                 repository that pushes out the actual releases. (And if
#                 I create a new project, I name its remote "release".)
#                 - I like to avoid the term "origin" to indicate that
#                   I'm deliberate about the remote name, so there should
#                   be no confusion about what the remote represents.
#   'starter'     When I clone someone else's project, or if I fork a
#                 project, I name the project repository's remote "starter".
#                 That is, the "proving" and "release" remotes points to
#                 repositories under my control, but "starter" does not,
#                 and references the most-upstream remote.
#   'myclone'     When I fork a project but do not plan to contribute to
#                 it, I'll name the remote "myclone". The name is arbitrary,
#                 but using a name other than "proving" or "release" ensures
#                 the git-my-merge-status command will not incorrectly
#                 diagnose the state of my local working tree.
#
# - Branch names:
#
#   Most of the commands below work on the current branch, except
#   for git-since, which assumes there's a "release" branch; and
#   git-cleanup, which removes merged branches not identified as
#   a "core" branch, one of: liminal|proving|release|private|main|trunk|develop.
#
#   'release'     For any project I share/publish publicly, I always have
#                 at least a "release" branch. When I develop new code, I
#                 either commit directly to "release", or I'll use a feature
#                 branch (named something other than one of the core names)
#                 and later merge that work into release.
#
#   'private'     For any project I do not publish but that's private to
#                 me, I generally have just one branch that I name "private",
#                 mostly to remind me (when I run `git branch`) that the
#                 project I'm working on is a private project.
#
#   'proving'     For any public project under active develop, in addition
#                 to the "release" branch, I'll maintain a "proving" branch
#                 where I commit code under it's ready to be released. Other
#                 people might call the "proving" branch something different,
#                 such as "main", "trunk", or "develop", to name a few.
#
#   'main', 'trunk', 'develop'
#                 Similar in concept to 'proving'. While I don't use this
#                 branch name, it's recognized by at least a few commands,
#                 such as git-cleanup (below) and git-cleanbr (under bin/)
#                 that remove feature branches (but not any "core" branch).
#
#   'liminal'     As Wikipedia states, "In anthropology, liminality is the
#                 quality of ambiguity or disorientation that occurs in the
#                 middle stage of a rite of passage." I use the branch name
#                 "liminal" on branches that I push remotely but that I later
#                 rebase. That is, other developers should not base their
#                 work on this branch, but I'll eventually rebase it before
#                 merging it to the "proving" branch. The "liminal" branch
#                 is essentially a feature branch, but one that I push to a
#                 remote so that it's backed up.
#
#   'wip/YYYY-MM-DD-*'
#                 Used for [w]ork [i]n [p]rogress branches. While none of
#                 the commands in git-smart are concerned with WIP branches,
#                 some spun-off projects do (such as git-my-merge-status),
#                 so it's worthy of note.
#
#   'tip/YYYY-MM-DD-abcdef01'
#                 Used for tipped forks, also not a concern of git-smart,
#                 but recognized by git-my-merge-status, so also so noted.
#                 A "tip" branch is a branch of a forked project that's
#                 ahead of the upstream's main development branch, but
#                 that you don't except/want to submit as a pull request.
#                 Think unique features you add that you're certain don't
#                 belong upstream, or that you don't think an upstream
#                 maintainer will accept. As such, you'll periodically
#                 rebase your changes atop the upstream remote branch,
#                 say, 'refs/remotes/release/release'. You'll probably
#                 also not have a local main development branch (i.e.,
#                 you'll delete the "release" branch after cloning your
#                 fork, and you'll change the default branch on GitHub
#                 before deleting the "release" branch from there as well).
#                 - Tipping is a way to fork a project, and to make some
#                   changes without submitting an upstream pull request,
#                   but also to not publish a divergent "release" branch
#                   that you'd have to force-push to keep up to date. By
#                   using the "tip/YYYY-MM-DD-abcdef01" naming scheme,
#                   any time the upstream branch changes, you create a
#                   new tip branch, rebase your work, and publish a new
#                   tip. Obviously, this might be tedious if the upstream
#                   branch changes frequently, but I find myself only doing
#                   this on mostly stable projects that I've forked and need
#                   to tweak (such as my
#                     https://github.com/hotoffthehamster/click-hotoffthehamster
#                   forked project). Also, by following this workflow and
#                   naming scheme, we're broadcasting better what's going
#                   on (and avoiding new DEVs being misled by a 'release'
#                   branch that doesn't match the upstream project's).

# #######################################################################
# ***                       "Engage Your Core"                        ***
# #######################################################################

[core]
  # Configure the pager.
  # - Re: Not using `most`, not `less`, for the pager, because:
  #   - Using `most` looks a lot like using `less`, but note that `most`
  #     does not map Vim keys like `less` does. One might say that `most`
  #     isn't quite more than `less` so much as it is just neither `less`
  #     nor more. (By which I mean, I prefer `less` because I can use the
  #     same keys that Vim uses to browse and search.)
  #   - One possible advantage with `most` is to call it with some options,
  #     e.g., use `+s +'/---'` to advance `most` to the first change in the
  #     diff (effectively just skipping the first two lines of the diff...).
  #     E.g.,
  #           pager = most +s +'/---'
  #     But, like I said, I'd rather have Vim-like search and navigation bindings.
  # - Setting the pager configures `git diff|log|mergetool` to use `less`
  #   to display text.
  # - Use `-R`, so `less` interprets ANSI color codes, otherwise they're
  #   shown raw, e.g., "[ESCapes234".
  pager = less -R

  # Configure the editor.
  # - Similar to how Vim defers to another application for paging, Vim also
  #   defers to another application for editing, e.g., what's invoked when
  #   you run `git ci -v`, for one, or `git rebase -i ...`, for another.
  # - Git defaults to using the (Bash) "EDITOR" environment variable to
  #   determine which application to run. So generally you don't need to
  #   specify it here, unless you want to do something special.
  #   - E.g., for a while, I had Vim startup issues when run from git, so
  #     I just made a Bash script that essentially called `vim --noplugin`,
  #     and then I wired it here, e.g.,
  #         editor = ~/.local/bin/git-vim
  #     or even just:
  #         editor = vim --noplugin
  #     but then I got off my tuchus and fixed my Vim scripts.
  #     So I'm not setting `editor` here.
  #     - You should rely on the EDITOR environ.
  # SKIPPING:
  #   editor = ...

  # Configure git's taste for whitespace.
  # - I like a blank line at the end of every file. This ensures that when I
  #   jump the cursor to the end of a file, it then rests at the first column
  #   of a new line, as opposed to being placed in the last column of some
  #   unknown-length line of characters.
  #   - But git complains when you add files that have a trailing new line.
  #       So tell git not to worry or bark at you.
  #   - Ref:
  #       https://stackoverflow.com/questions/27059239/git-new-blank-line-at-eof
  #   - See also:
  #       whitespace = cr-at-eol
  whitespace = -blank-at-eof

# #######################################################################
# ***                          git colorful                           ***
# #######################################################################

# - We could enable color one by one, e.g.:
#
#     branch = auto
#     diff = auto
#     status = auto
#     interactive = auto
#
#   Or we could enable 'em all at once, e.g.:
#
#     ui = auto
#
# - Instead of `auto`, we could use `always`, so that
#   piping pipes colors, e.g.,
#
#       git config color.ui always
#       git log --stat | less  # So colorful!
#
#   But then -- *caveat* -- you'd want to disable color when parsing output,
#   lest the color codes break your code, i.e., ruin string comparisons, etc.
#   Which you could work around with a one-off config override, e.g.,
#
#       git -c color.ui=off ...
#
#   or by using the global no-color option:
#
#     git --no-color ...
#
#   but that's just too messy.
#
#   Going with 'auto' seems like a happy place.

[color]
  ui = auto

# 2020-02-09: I added these colors years ago. Source unknown.
# - But they've withstood the test of time. They look nice.

[color "branch"]
  current = green bold
  local = green
  remote = red bold

[color "diff"]
  meta = yellow bold
  frag = magenta bold
  old = red bold
  new = green bold

[color "status"]
  added = green bold
  changed = yellow bold
  untracked = red

# #######################################################################
# ***                          diff N merge                           ***
# #######################################################################

[diff]
  # Use the 'minimal' diff algorithm to achieve desired diff behavior.
  # - For example, in a reST file containing section headers, like "#######",
  #   I cut and pasted a big block of text, and the default greedy git diff
  #   algorithm, myers, shows the move as a bunch of small deletions and
  #   insertions. (But if you diff using `meld`, you see one big deletion
  #   and one big insertion.) We can use a different algorithm to make the
  #   diff easier to parse.
  # - Choices:
  #    default    aka "myers".
  #    minimal    Spend extra time to ensure smallest possible diff produced.
  #    patience   Use "patience diff" algorithm when generating patches.
  #    histogram  This algorithm extends the patience algorithm to
  #               "support low-occurrence common elements".
  algorithm = minimal

  # Hide the path prefix from git-diff output.
  # - If you'd like to be able to double-click and copy-paste from git-diff
  #   output, suppress the awkward "a/" and "b/" path prefixes.
  #   - I think these prefixes are holdovers from old SCMs. See:
  #       https://stackoverflow.com/questions/6764953/
  #         what-is-the-reason-for-the-a-b-prefixes-of-git-diff
  noprefix = true

  # NOTE: The diff.noprefix option does not apply to the 'a/' and 'b/'
  #       prefixes shown in interactive patch mode, i.e., on `git add -p`.
  # - The `--no-prefix` option is documented in `git-diff --help`, but it's not
  #   found in `git-add --help`. (So I'm guessing there's no builtin mechanism.)
  # - But don't fret! git-smart has the answer!
  #   - The `diff-filter-garden` script shows how to strip the 'a/' and 'b/'
  #     prefixes -- but it also adds a visual break between interactive patch
  #     hunks, which you may or may not like. So if you just want the prefix
  #     stripping, you'll have to pull it out yourself!
  #     - Look for and copy the interactive.diffFilter setting from the
  #       `.gitconfig.local.example` file to your own config to try it out.

# A more informative binary diff, how brilliant!
# - Found solution to more meaningful PDF diff at:
#   https://superuser.com/questions/706042/how-can-i-diff-binary-files-in-git
# - See the `*.bin diff=bin`, etc., rules in ~/.config/git/attributes, and ref:
#   man 5 gitattributes

[diff "bin"]
  textconv = hexdump -v -C

[diff "pdf"]
  textconv = pdfinfo

[diff "zip"]
  textconv = unzip -v

# Choose which merge tool to use by default.
# Options:
#   tool = meld
#   tool = vimdiff
#   tool = diffconflicts

[merge]
  tool = meld

# `git mergetool` makes intermediate *.orig files but
# doesn't delete them unless we tell it to delete them.

[mergetool]
  keepBackup = false

# (lb): I rarely use pull. If I forsee conflicts, or am not positive
# they are not any, I'll git-fetch and then git-merge deliberately. If
# I ever git-pull, I'm anticipating it'll be like `git merge --ff-only`.

[pull]
  ff = only

# #######################################################################
# ***              Ever-expanding Git Aliases Collection              ***
# #######################################################################

# NOTE: The aliases are split across multiple groups listed below,
#       hopefully to make the remainder of the file easier to read
#       and maintain.

# NOTE: The only way to pass a global option to git is to shell out. AFAIK.
#
#       So, e.g., instead of a simple alias such as:
#
#         br = branch
#
#       You'll see a slightly more complicated alias, e.g.,
#
#         br = !git --no-pager branch

# TRICK: You can wrap shell code in an anonymous Bash function
#        when you need to shell out, to have access to, well,
#        at least the 'local' function (which can only be used
#        in functions).
#        - I read that you need to use an anonymous function to
#          access command line variables and shell expansion.
#          But I have aliases that shell out without a function
#          wrapper, and they access numbered arguments
#          ($1, $2, etc.) just fine.
#       - E.g., it's the difference between writing this:
#           my-alias = ! echo Hello
#         and this:
#           my-alias = "! f() { echo Hello; }; f"
#         but not this (syntax error without quotes):
#           my-alias = ! f() { echo Hello; }; f
#       - Here's the article, which is good in its own right:
#           https://www.atlassian.com/blog/git/advanced-git-aliases
#       - Nonetheless, you'll see some shell code below wrapped in a
#         function, and some code not. Just kinda depends.
#       - Oh! I think unwrapped functions get arguments at the end, always,
#         e.g., given the alias
#           view = !echo \"FOO $@ BAZ\"
#         then
#           $ git view bar
#           FOO bar BAZ bar
#         So use the wrapper when necessary, e.g.,
#           view = "! f() { echo \"FOO $@ BAZ\"; }; f"
#         then it works more like one might expect:
#           $ git view bar
#           FOO bar BAZ
#
# NOTE: Shell code is run by POSIX (e.g., dash), not Bash, so
#       avoid constructs such as [[ ]] unless you invoke Bash.
#       - E.g., this is wrong:
#           test1 = "! f() { [[ -z \"$1\" ]] && echo 'Z!' || echo 'n.'; }; f"
#         Because it won't be run by Bash, and will throw an error, e.g.,
#           $ git test1 "sdff"
#            f() { [[ -z "$1" ]] && echo 'Z!' || echo 'n.'; }; f: 1:
#             f() { [[ -z "$1" ]] && echo 'Z!' || echo 'n.'; }; f: [[: not found
#           n.
#         But you could instead shell out your shell code to Bash, e.g.,
#           test2 = ! "/usr/bin/env bash -c \"f () { [[ -z \\\"$1\\\" ]] && echo Z || echo n; }; f\""
#         or you could just rewrite it to be POSIX-compliant, e.g.,
#           test3 = "! f() { [ -z \"$1\" ] && echo 'Z!' || echo 'n.'; }; f"
#
# NOTE: One final shell code note: You need to \-delimit line breaks;
#       and you need to use a semicolon after each line (i.e., you
#       cannot rely on newlines to signal the parser what's what).

# NOTE: Within each [alias] section, I've arranged my My Most Popular Git
#       Aliases up top (those that I use the most), above a mini-ruler:
#
#       # -------

# #######################################################################
# ***                     Branch Command Aliases                      ***
# #######################################################################

[alias]

  br = !git --no-pager branch

  # - Use `git brs` to show all branches, including remote branches.
  # - git-brs is inherently aliased because found on PATH.
  #    brs = !${GITSMART_BIN:-${HOME}/.local/bin}/git-brs \"$@\"

  # -------

  # Bro!
  bro = "! f () { \
    local tracking_br_rem tracking_remote; \
    tracking_br_rem=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}); \
    if [ $? -ne 0 ]; then \
      >&2 printf '%s\\n' 'ERROR: Set tracking branch to use this command'; \
      return 1; \
    fi; \
    tracking_remote=$( \
      printf '%s' \"${tracking_br_rem}\" \
      | /usr/bin/env sed -e 's#/.*$##' \
    ); \
    \
    printf '\\n'; \
    printf '%b\\n' \"\\\\e[31mLocal branches\\\\e[0m\"; \
    printf '%b\\n' \"\\\\e[31m--------------\\\\e[0m\"; \
    git --no-pager branch -vv; \
    printf '\\n'; \
    printf '%b\\n' \"\\\\e[31mRemote branches (on '${tracking_remote}')\\\\e[0m\"; \
    printf '%b\\n' \"\\\\e[31m---------------\\\\e[0m\"; \
    git --no-pager ls-remote --heads ${tracking_remote} \
      | /usr/bin/env sed 's?.*refs/heads/??' \
      | /usr/bin/env sed -e \"s/^/\\ \\ /\" && \
    printf '\\n'; \
  }; f"

  brs-all = !git --no-pager branch -avv

  # Delete merged branches except any conventionally-named branch (e.g., the
  # main development branch, what I call "proving" or others might call "main";
  # the release branch, often called "release"; or a "private" branch, which is
  # the branch label I use in private repositories I don't publish), and not
  # the current branch, either.
  #   https://gist.github.com/jantimon/5b9fd9330f38d076a374c03fcbb788e1
  cleanup = "! f () { \
    local tracking_br_rem tracking_remote; \
    tracking_br_rem=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}); \
    if [ $? -ne 0 ]; then \
      >&2 echo 'ERROR: Set tracking branch to use this command'; \
      return 1; \
    fi; \
    tracking_remote=$(printf '%s' \"${tracking_br_rem}\" | /bin/sed -e 's#/.*$##'); \
    \
    git remote prune ${tracking_remote} && \
    git branch --no-color --merged \
      | egrep -v '(^\\*liminal|proving|release|private|main|trunk|develop)' \
      | xargs git branch -d; \
  }; f"

  # Show the current branch name.
  # (I added this alias years ago, but I hardly use it.
  #  - I usually check for the branch name using `git br`, unless I need to
  #    script it, and then I just call rev-parse directly.
  #    - I would have guessed that 'br' would be faster to type the 'cur',
  #      but they're about the same.
  #    - I think that `git br` is more versatile -- in addition to seeing what
  #      branch the tree is on, it also reminds me of what other branches exist.
  #    - The only reason I see to keep this alias is as a rev-parse usage example.)
  # Weird: git rev-parse defaults --abbrev-ref per core.warnAmbiguousRefs, but
  #          rev-parse --abbrev-ref HEAD
  #        on Linux returns the --abbrev-ref=loose form, e.g., "my_branch", but
  #        on macOS it runs like --abbrev-ref=strict, e.g., "heads/my_branch".
  #        We want to be consistent, and to show the simpler name.
  cur = rev-parse --abbrev-ref=loose HEAD

  # -------

  # - Use `git-cleanbr` to delete a branch locally and on the remote,
  #   after switching to 'develop' or another branch.
  # - git-cleanbr is inherently aliased because found on PATH.
  #    cleanbr = !${GITSMART_BIN:-${HOME}/.local/bin}/git-cleanbr \"$@\"

  # - Use `git-cob` to checkout a branch from an existing remote for which
  #   there is no local tracking branch, but for which there are multiple
  #   remotes with the same-named branch, and you cannot simply
  #   `git checkout <branch>` but have to be remote-specific.
  # - git-cob is inherently aliased because found on PATH.
  #    cob = !${GITSMART_BIN:-${HOME}/.local/bin}/git-cob \"$@\"

  # - Use `git-coc` to create a new branch, switch to it, and push it.
  # - NOTE: I tried doing this inline, e.g.,
  #     coc = !git branch ${1} && git checkout ${1} && git push ${2:-origin} ${1} -u
  #   but git puts the args after the command, so the git push ends up looking like:
  #     git push ${2:-origin} ${1} -u ${1}
  #   which obviously fails. So shell out!
  # - git-coc is inherently aliased because found on PATH.
  #    coc = !${GITSMART_BIN:-${HOME}/.local/bin}/git-coc \"$@\"

  # - Delete branches that are "gone" on the remote.
  #   - You can find tracking branches with missing remote branches via:
  #       git branch -vv --no-color | grep ': gone]'
  #     and then you can big-D delete them thusly:
  #       git branch -D <branch>
  # - git-gone is inherently aliased because found on PATH.
  #    gone = !${GITSMART_BIN:-${HOME}/.local/bin}/git-gone \"$@\"

# #######################################################################
# ***                         Logging Aliases                         ***
# #######################################################################

# A few of the --pretty git log format options:
#
#   %Cred     red text
#   %C(cyan)  Choose from: (normal, black, red, green, yellow, blue, magenta, cyan and white)
#   %h        abbreviated commit hash
#   %Creset   reset text color
#   %x0       print a byte from hex code (09: \t)
#   %an       author name
#   %x09      TAB
#   %ad       author date (format respects --date= option)
#   %x09      TAB
#   %d        ref names, like the --decorate option of git-log(1)
#   %s        subject
#   %<(<N>[,trunc|ltrunc|mtrunc]) make the next placeholder take at least N columns...
#     * 79c812f My Name  Fri Mar 1q0 17:05:27 2017  Update README.
#     * 2deef48 My Name  Thu Mar 9 13:02:57 2017 Fix something.
#     %<(24) is 24 chars for the "Fri Mar 10 17:05:27 2017" date. %>(24) to right justify.
#   If you add a ` ` (space) after % of a placeholder, a space is inserted immediately
#   before the expansion if and only if the placeholder expands to a non-empty string.

[alias]

  # Use `git l` to show the latest log message.
  # - (I tried other, longer names, such as `last`, `l1`, and `l`.
  #    But I like 'l' the best.
  #   - I like 'last' because it's descriptive, and the user probably doesn't
  #     have to guess what it does -- but it's annoying to type an 'a' after
  #     an 'l' (such a stretch across the keyboard!).
  #   - I like 'l1' because it's short, and it has a good pneumonic --
  #     1 log record, or 'l1' (well, '1l', I suppose, but whatever).
  #   - And I like 'l' because it's also short -- but I don't normally like
  #     single character abbreviations, because it makes searching more
  #     difficult (there are usually tons of false-positives to sift through).
  #     Also, I don't like to use a coveted single character abbreviation
  #     unless I think it'll be well-used.
  #   - In this case, with 'l', I do like the single character -- it's quick
  #     to type, and it's not like this single character appears any place
  #     other then here (so there's no grep-pollution to worry about). Also,
  #     I can also use the pneumonic of wanting one log record: And what 1
  #     character does the word 'log' start with? It's an 'l'! Finally, I
  #     think I will use this option frequently (I've already started),
  #     so let's go ahead and use up a single character alias! Worth it!!)
  l = !git --no-pager log -1

  # Git command to show tag creation dates.
  # - Optional: Add --graph to see branching lines. E.g.,
  #     `git tags --graph`
  tags = \
    log \
      --date-order \
      --tags \
      --simplify-by-decoration \
      --pretty='format:%C(green)%ad %C(red)%h %C(reset)%D' \
      --date=short

  # -------

  # Show how many times each file has been edited, aka churn.
  #
  # - Show check for the whole repo:
  #
  #   $ git churn
  #
  # - Show churn for specific directories:
  #
  #   $ git churn app lib
  #
  # - Show churn for a time range:
  #
  #   $ git churn --since='1 month ago'
  #
  # - Obvi., you can pass any git-log argument to churn.
  #
  # - Credits: Written by Corey Haines.
  #            Scriptified by Gary Bernhardt.
  #            Hacked by me (moved `sort -g` before `awk`, and split long line).
  churn = ! \
    git --no-pager log --all -M -C --name-only --format='format:' \"$@\" \
    | sort \
    | grep -v '^$' \
    | uniq -c \
    | sort -g \
    | awk 'BEGIN {print "count\tfile"} {print $1 \"\t\" $2}'

  # -------

  # Use `git lg` to show a very concise single-line log history.
  #
  # - Shows one log entry per line formatted like:
  #
  #   * HASH - DESCRIPTION (X days ago) <AUTHOR>
  #
  #   E.g.,
  #
  #   * acbd1234 - Docs: Update README. (4 days ago) <Your Name>
  #
  # - Thanks to:
  #
  #   https://www.leaseweb.com/labs/2013/08/git-tip-beautiful-colored-and-readable-output/
  lg = \
    log --graph --abbrev-commit --date=relative \
        --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'

  # -------

  # Use `git lg1` to see the best representation I could make of the `tig`  log view.
  #
  # STYLE: Prefer `%C(foo)` to `%Cfoo` for readability.
  # INFO.: `less -R` required here, but not if you paste this command to your terminal.
  lg1 = "! f() { \
    git \
      --no-pager \
      log \
      --color=always \
      --date=\"format:%a %F %H:%M %z\" \
      --pretty=\"format:%h %C(blue)%cd %C(green)%<(22)%an%C(reset)%C(blue)o%C(reset)%C(red)%d%C(reset) %s\" \
      --graph | less -S -R; \
  }; f"
  # Hint:
  #
  #     --color=always        Because of the |pipe.
  #
  #     --date="format:..."   Pairs well with %cd
  #       %a %F %H:%M %z        E.g., "Sat 2020-11-21 16:58 -0600"
  #
  #     --pretty="format:..." I got the format looking almost like `tig`,
  #                             but tig might be doing something custom. I do
  #                             not see how to generate a similar graph column.
  #       %Cblue              Blue foreground color
  #       %Cgreen             Green foreground color
  #       %Cred               Red foreground color
  #                             Note: %Cblue, %Cgreen and %Cred all I see
  #                             defined in man git-log, but %Ccyan works, or
  #                             even %C(cyan) -- +1 parens, it's easier to read.
  #       %Creset             Resets color
  #       %<(22)              Right-pads with spaces to 22-characters
  #       %h                  Abbreviated commit hash
  #       %cd                 Committer date (format respects --date= option)
  #       %an                 Author name
  #       o                   You'll see in `tig`, part of its custom --graph
  #       %d                  Ref names, like the --decorate option of git-log(1)
  #       %s                  Subject
  #
  #     --graph               Draws graphical rep. of history on left hand side;
  #                             not quite like tig, which draws history after
  #                             the author's name and before the suject, not sure
  #                             how it does it.
  #
  #     | less -S             -S, aka --chop-long-lines, to not wrap lines
  #     | less -R             -R, or --RAW-CONTROL-CHARS: “Like -r, but only ANSI "color"
  #                                escape sequences are output in "raw" form. Unlike -r,
  #                                the screen appearance is maintained correctly in most
  #                                cases.”

  # -------

  # Use `git log1` to show exclusive history for the currently branch.
  #
  # - Shows one log entry per line, formatted like:
  #
  #   * HASH AUTHOR Mon Jan 01 00:00:00 2001  (HEAD -> my-branch)DESCRIPTION
  #   * HASH AUTHOR Mon Jan 01 00:00:00 2001  DESCRIPTION
  #   * ...
  #
  # - HINT: %C(auto) uses colors like git-log normally does (e.g., per color.ui).
  #
  # - HINT: %+s will add a linefeed between meta and subject.
  #
  # - NOTE: I cannot get a space between the %D ref name and the %s subject. Ah, well.
  log1 = \
    log --graph --abbrev-commit --date=local --decorate \
        --pretty="%C(yellow)%h%x09%C(cyan)%<(12)%an%x09%C(blue)%>(24)%ad%C(auto)%x09%D%s"

  # -------

  # Use `git logs` to show more inclusive history than `git logs`.
  #
  # - It looks similar to `git log1` but includes merged branch logs, too.
  #
  # - Shows one log entry per line, formatted like:
  #
  #   * HASH AUTHOR DATE "HEAD -> my-branch"DESCRIPTION
  #   * HASH AUTHOR DATE DESCRIPTION
  #   * ...
  #   | * HASH AUTHOR DATE "merged-branch"DESCRIPTION
  #   | * HASH AUTHOR DATE DESCRIPTION
  #   | * ...
  #   |/
  #   * ...
  #
  # - Thanks to:
  #
  #   https://stackoverflow.com/questions/9437182/git-show-all-branches-but-not-stashes-in-log
  #
  # - HINT: The date is added to the output via the --pretty, not the --date.
  logs = \
    log --graph --abbrev-commit --date=local --decorate \
        --branches --remotes --tags --notes --oneline  \
        --pretty="%C(yellow)%h%x09%C(cyan)%<(12)%an%x09%C(blue)%>(24)%ad%C(auto)%x09%D%s"

  # -------

  # Use `git since` to show the log history since the last common ancestor
  # between two branches.
  # - If no branches are specified, finds the ancestor of 'release'
  #   and the current branch.
  # - If a single branch is specified, finds the ancestor of 'release'
  #   and the named branch.
  # - If two branches are specified, finds the ancestor of the two
  #   named branches.
  # MAYBE/2020-07-01: Rather than assume "release" branch, iterate through a
  # list of "core" branches, e.g., see git-cleanbr's ${GITSMART_CORE_BRANCHES},
  # and identify the "progenitor" branch (see git-my-merge-status for meaning
  # of progenitor branch). But I don't use this command often (at all), so do
  # not really care.
  since = "! f () { \
    oth_br=${1:-release}; \
    local cur_br=$(git rev-parse --abbrev-ref HEAD); \
    ref_br=${2:-${cur_br}}; \
    local common_ancestor=$(git merge-base ${ref_br} ${oth_br}); \
    git log ${common_ancestor}..HEAD; \
  }; f"

# #######################################################################
# ***                         Commit Aliases                          ***
# #######################################################################

[alias]

  # Simple git-commit shortcut.
  ci = commit

  # (lb): Used 60% of the time (type message at prompt).
  cm = commit --message

  # - Some other commit alias ruminations:
  #   - Stage modified and deleted files, but not new files:
  #       git commit -a/--all
  #   - Show diff of what's being committed at bottom of commit message editor sess:
  #       git commit -v/--verbose
  #   - Combine them both for a quickie add-all, review, compose, and commit:
  #       cia = commit -a -v

  # Use `git cv` to open your EDITOR to compose a commit message.
  #
  # - One goal I have in life is to stop composing commit messages
  #   at the terminal prompt, and to *always* use Vim (my EDITOR).
  #
  #   (lb): Used 40% of the time (type message at prompt).
  cv = commit -v
  # 2020-11-24: `git cv` not sticking, let's give `git ce` a whirl,
  # as in, commit message using EDITOR.
  ce = commit --verbose

  # ***

  # Use `cim` and `cin` to amend the last commit, even with unstaged work.

  # (lb): `commit --amend` the long way: --fixup + wip + rebase + pop1.

  # (lb): 2020-11-24: At least I can say I use `cim` and `cin` a lot.
  # - I first had `cin` aliased from `cia` (commit/ci + amend/a), but I
  #   feel like `cin` complements `cim` better, and I like the idea of
  #   c-in → commit-in → commit into last commit (and then cim is like
  #   cim → commit-into-message → commit into last commit & edit message). #pneumonics

  cim = commit --amend

  cin = commit --amend --no-edit

# #######################################################################
# ***                   Staging and Commit Aliases                    ***
# #######################################################################

[alias]

  st = status

  # -------

  ad = add -p
  # 2020-11-24: I didn't even remember `git ad` was here.
  # - Would I remember instead if it was `git ap`?
  ap = add -p
  # ADDitional noise.
  # - Ref:
  #   https://www.reddit.com/r/git/comments/6ecr4o/git_dad/
  #   https://icanhazdadjoke.com/api
  # - Bored?
  #   curl -H "Accept: application/json" "https://icanhazdadjoke.com/search?term=bar"
  dad = !curl "https://icanhazdadjoke.com/" && echo && git add
  rad = !echo '   (⌐■_■)' && git add

  # -------

  wip = ! \
    git add -A && \
    git ci -m WIP

  # See: bin/git-wipit
  wippit = wipit

# #######################################################################
# ***                       Files List Aliases                        ***
# #######################################################################

[alias]

  ls = ls-files

  # Use `git ignored` to show --assume-unchanged files.
  # - Docs/Ref:
  #     -v: "Similar to -t, but use lowercase letters for files that
  #          are marked as assume unchanged (see git-update-index(1))."
  #     https://stackoverflow.com/questions/2363197/
  #       can-i-get-a-list-of-files-marked-assume-unchanged
  ignored = !git ls-files -v | grep "^[[:lower:]]"

# #######################################################################
# ***                      Show File Alias(es)                        ***
# #######################################################################

[alias]

  # Fetches and shows file from specific commit/branch, e.g., the long way:
  #
  #   git show develop:path/to/file.js | view -c 'set ft=javascript' -
  #
  # or the short way:
  #
  #   git view develop:path/to/file.js
  #
  # Note the final `-` so that Vim knows to read from stdin.
  #
  # Note if you specify just the commit:path, this command will use the
  # file extension for the Vim 'filetype' (so that syntax highlighting
  # works); otherwise, you can specify the filetype as the second arg.
  view = "! f() { \
    local extension=\"$2\"; \
    if [ -z \"${extension}\" ]; then \
      extension=\"${1##*.}\"; \
    fi; \
    git show \"$1\" | \
      view -c \"set ft=${extension}\" -; \
  }; f"

# #######################################################################
# ***                          Diff Aliases                           ***
# #######################################################################

[alias]

  # Use `git dc` to show a diff of what's already been *staged* (which
  # is what you'd see at the bottom of a `git commit -v` edit session).
  # 2020-03-22: On second thought, because I have Bash aliases at `dff`
  # and `dcc`, and because `dc` is the calculator app, perhaps this git-dc
  # is not as useful/potentially confusing.
  dc = !git --no-pager diff --cached
  # `dcc` like `dc` except no pager, dumps to terminal.
  dcc = !git diff --cached

  # Use `git dd` to dump the diff to the terminal, bypassing the pager.
  dd = !git --no-pager diff \"$@\"

  # Use `git df` to run diff... if you're that lazy you can't type two
  # additional characters.
  # - I git-diff fairly frequently, so I've added an even easier
  #   Bash alias to my user environment
  #     # <somewhere deep inside my .bashrc>
  #     alias dff='git diff'
  df = !git --no-pager diff
  # - Because I've got `dff` aliased from Bash, I have same
  #   aliased from git, so I can wire my brain both ways.
  dff = diff

# #######################################################################
# ***                     Undo and Undodo Commits                     ***
# #######################################################################

[alias]

  # See `git undo` command at: bin/git-undo

  # -------

  # HINT: If you `rollback` or `undo` accidentally and need to recover,
  #       you can find the commit you blew away in the reflog. Just run:
  #
  #         git reflog
  #
  #       (Though if you just want to undo an undo, run `git undo-undo`.)

  # -------

  # Use `git rollback` to unwind the latest commit and unstage changes.
  # - Equivalent to (or just similar?):
  #     git undo && git reset HEAD *
  # 2020-05-24: I find myself running rollback, then `git l`, so combine the two!
  # Was:
  #  rollback = reset --mixed @~1
  # Now include a one-liner of the commit you land on after rolling back.
  # Use case: I have multiple WIPs and want to rollback latest sane commit.
  # FIXME/2020-06-15: Remove `rollback`, I think I've switched to `pop1` completely!
  rollback = ! \
    git reset --mixed @~1 && \
    git --no-pager log -1 --pretty=oneline --abbrev-commit
  # 2020-05-27: Getting lazy with age.
  # - On second thought, any combo with 2 keys runs risk of being typed
  #   and ENTERed without me thinking. I've done it before in other cases.
  #    rb = rollback
  pop1 = ! \
    git reset --mixed @~1 && \
    git --no-pager log -1 --pretty=oneline --abbrev-commit

  # -------

  # Use `git undo` to undo the latest commit, but not to unstage.
  #
  # - The undo command is in its own file on PATH, so
  #   that it runs, not git-extras' /usr/bin/git-undo.
  #
  #   See:
  #
  #     bin/git-undo
  #
  # - This is useful if you want to rewrite the commit message,
  #   or if you want to incorporate changes without having to
  #   perform a squash operation.
  #
  # - NOTE: The git-extras package installs its own /usr/bin/git-undo,
  #         which shadows any alias defined here, in the .gitconfig.
  #
  #   - So while this operation could be an alias because it's so simple,
  #     it instead must be a file found (first) on PATH.
  #
  # - The operation is very simple. It's essentially:
  #
  #     undo = reset --soft @~1

  # -------

  # Use `git undo-undo` to undo an undo, duh!
  # - The undo-undo command undoes a --soft reset.
  undo-undo = reset 'HEAD@{1}'

# #######################################################################
# ***                 Checkout Fetch Push Pull Rebase                 ***
# #######################################################################

[alias]

  # Use `git co` instead of `git checkout` because the latter is too much typing.
  co = checkout

  # Use `git po` to push to the most commonly pushed remote (probably), "origin".
  # And use `git pu` to push to another commonly used remote name, "upstream".
  po = push origin HEAD
  pu = push upstream HEAD
  # 2020-06-18: (lb): My latest workflow adopts the remote names "proving"
  # and "release" instead of "origin" and "upstream". See mega-comment in
  # my git-my-merge-status project for the reason for the innovation.
  pp = push proving HEAD
  pr = push release HEAD

  # Use `git re` to show the URL of each remote after its name.
  # 2020-03-11: Check out the new `bin/git-re` tidy remote reporter!
  # - LATER: Remove this alias. For now, telling YOU where to look.
  #  re = remote -v
  r = re

  # Run `git sup` periodically (or maybe after every git-pull) to process
  # any changes to the project submodules).
  sup = submodule update --init --remote

  # Use `git up` to stash changes, pull, rebase, and pop the stash.
  # - Benefit (IMO): Runs rebase; not merge like pull does by default.
  up = pull --rebase --autostash

  # -------

  # Use `git bump` to quickly run a common rebase operation.
  # - Without arguments, checks out the 'develop' branch, fetches from
  #   the 'upstream' remote; and rebases 'develop' atop 'upstream/develop'.
  # - You can specify the following optional arguments:
  #     git bump <local-branch> <upstream-remote> <upstream-branch> <local-remote>
  # - The command is essentially:
  #     git checkout 'develop'  # or the named branch ($1)
  #     git fetch 'upstream'  # or the named remote ($2)
  #     git rebase upstream/develop  # or the named upstream branch ($2/$3)
  # - git-bump is inherently aliased because found on PATH.
  #    bump = !${GITSMART_BIN:-${HOME}/.local/bin}/git-bump \"$@\"

  # Use `git fam` to fetch from both the 'origin' and 'upstream' remotes,
  # and to remove from the local branches list those branches deleted
  # from each of the two remotes.
  # (lb): See comments atop this file re: How branches are named.
  # - Former workflow: 'origin' and 'upstream'.
  fam = fetch --multiple origin upstream --prune
  # - Latest workflow: 'proving' and 'release'.
  fpr = fetch --multiple proving release --prune

  # Use `git fap` to fetch and prune branches deleted from each of the remotes.
  # - (lb): `--all` fails if any remote cannot be reached, which affects me
  #         particularly because every repo I've got tracks a backup repo on
  #         an offline storage device, which is rarely online. Meaning, --all
  #         almost --all'ways fails for me. Additionally, `--all` can take a
  #         while if there are many remotes.
  #         - As such, oftentimes it's better to be deliberate when fetching
  #         from remotes -- that is, consider using either of the commands
  #         `fam` or `fpr`, but not `fap`.
  fap = fetch --all --prune

  # Use `git pup` to push a branch and add tracking information (e.g., to
  # be used on a later `git pull`, or for `git status` to tell you things).
  # - I tried `git pu` for a spell, but it didn't stick, e.g.,
  #     pu = push -u origin HEAD
  #   which I think is because 'pu' is not as snappy as 'pup'.
  #   Pneumonically speaking, remember that you want to set the
  #   UPstream tracking information on Push, so it's called PUP.
  # - See also the more direct call to set just the tracking branch, e.g.,
  #     git branch -u <remote>/<branch>
  # 2020-07-01: I never use this command. Let's disable it.
  # - (I'll instead use, e.g., `git pp -u`, if I have to.)
  #  pup = push --set-upstream origin HEAD

# #######################################################################
# ***              Redoing Commits and Rewriting History              ***
# #######################################################################

[alias]

  # Show rebase recipe with '--fixup' commits ordered
  # and commanded to 'f'ixup.
  ria = rebase -i --autosquash

  # - Use case: Works well with `git ci --fixup=<>`, e.g.,
  #
  #     git ci --fixup=abcd1234 && git ria abcd1234^
  #
  # - Common workflow:
  #
  #   - While working on a new feature, I make a small change
  #     that should be part of a previous commit.
  #
  #   - Run `st` (git status) to see the file path, and copy it.
  #
  #   - Run `gitk -- <file> &` and find and copy appropriate commit hash.
  #
  #     - Or better yet find it with `git latest <search terms>`
  #       and then verify using `tig`, which has replaced gitk in my D2D.
  #
  #   - Run `git add -p <file>`, and then `git ci --fixup=<hash>`.
  #
  #   - Run `git wip` to commit other uncommitted changes.
  #
  #   - Run `git ria <hash>^` to fixup the small change to the past commit.
  #
  #   - Save and close the rebase script.
  #
  #   - Run `git pop1` to rollback the WIP commit.

  # If the rebase pauses and you need to resolve a conflict,
  # here's a shortcut to continue the rebase quickly.
  rc = rebase --continue

  # Git cherry-pick --continue.
  #     ░      ▒      ▓
  cpc = cherry-pick --continue

# #######################################################################
# ***                    Miscellaneous Git Aliases                    ***
# #######################################################################

[alias]

  # Empirically speaking.
  whoami = config user.email

  # SHA of the very first commit.
  first-commit = rev-list --max-parents=0 HEAD

# #######################################################################
# ***                  Your Private .gitconfig.local                  ***
# #######################################################################

# YOU/DEV: Put your [user] and other private config in a separate file
#          named '.gitconfig.local' that's located (symlinked) alongside
#          this file (in the same directory).

[include]
  path = .gitconfig.local

# #######################################################################
# ***                 Set your own Default Branch Name                ***
# #######################################################################

[init]
  # The template directory's contents are copied to a new working tree's
  # .git/ directory. We could also adds hooks, an info/exclude, etc., but
  # (for now) we just copy the HEAD file, which specifies the default branch.
  templateDir = ~/.config/git/template/

