#!/bin/bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/landonb/git-FlU#🌡
# License: MIT. Please find more in the LICENSE file.

reveal_biz_vars () {
  # Left-align with 5 spaces between name and URL:
  #  GITFLU_COLSEP="${GITFLU_COLSEP:-     }"
  #  GITFLU_ALIGNT="${GITFLU_ALIGNT:--}"
  # But I sorta like right-align with just 2 spaces:
  GITFLU_COLSEP="${GITFLU_COLSEP:-  }"
  GITFLU_ALIGNT="${GITFLU_ALIGNT:-}"

  # YOU: Leave at zero to use max width of single repo's remotes;
  #      or set to minimum width for all projects -- i.e., for `mr`
  #      multiple-repository reporting, you could run, e.g.,:
  #        mr -d / run bash -c 'GITFLU_MAX_WIDTH=12 git re'
  GITFLU_MAX_WIDTH=${GITFLU_MAX_WIDTH:-0}
}

# ***

declare -A -x GITFLU_REMOTE_CACHE

update_first_column_max () {
  local name=$1
  local name_len=$(echo -n "${name}" | wc --chars)
  [ ${name_len} -gt ${GITFLU_MAX_WIDTH} ] && GITFLU_MAX_WIDTH=${name_len}
}

git_remote_assemble_cache () {
  local last_op=''
  local last_url=''
  local line=''
  while IFS= read -r line; do
    # 3 parts: name; url; "(fetch)" or "(push)".
    set -- ${line}
    local name=$1
    local url=$2
    local op=$3
    if [ "${op}" = "(fetch)" ]; then
      [ -n "${last_op}" ] && [ "${last_op}" != "(push)" ] && \
        >&2 "Unexpected: Previous line's op not “(push)”."
      last_op="${op}"
      last_url="${url}"
      update_first_column_max "${name}"
      GITFLU_REMOTE_CACHE[${name}]="${url}"
    elif [ "${op}" = "(push)" ]; then
      # (lb): It's probably possible to have other ops, or disparate
      # URLs for the same remote, but I've never seen it in my usage,
      # so alerting.
      [ -n "${last_op}" ] && [ "${last_op}" != "(fetch)" ] && \
        >&2 "Unexpected: Previous line's op not “(fetch)”."
      [ -n "${last_url}" ] && [ "${last_url}" != "${url}" ] && \
        >&2 "Unexpected: Previous line's url not the same."
      last_op="${op}"
      last_url="${url}"
      # Only call the callback once, once first line for remote,
      # which is the "(fetch)" line, handled above.
    else
      >&2 "Unexpected: Unknown op “${op}” for “${name}”."
    fi
  done < <(git remote -v)
  # CURIOUS/2020-03-11: What's difference between these two:
  #   done < <(git remote -v)
  #   done <<< "$(git remote -v)"
}

callback_print_remote_info () {
  local name=$1
  local url=$2
  eval "printf '%${GITFLU_ALIGNT}${GITFLU_MAX_WIDTH}s${GITFLU_COLSEP}%s\n' '${name}' '${url}'"
}

pretty_print_tidy_remote_list () {
  local callback=$1
  for remote in \
    'proving' \
    'release' \
    'origin' \
    'upstream' \
    $(git remote | grep -v -e 'proving' -e 'release' -e 'origin' -e 'upstream' | sort \
  ); do
    ! [ ${GITFLU_REMOTE_CACHE[${remote}]+x} ] && continue
    callback_print_remote_info "${remote}" "${GITFLU_REMOTE_CACHE[${remote}]}"
  done
}

git_remote_list_tidy () {
  git_remote_assemble_cache
  pretty_print_tidy_remote_list
}

main () {
  reveal_biz_vars
  git_remote_list_tidy "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "${@}"
fi

