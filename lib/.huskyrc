# Husky sources this file from POSIX environment (not Bash).
# vim:tw=0:ts=2:sw=2:et:norl:ft=sh
# Author: Landon Bouma <https://tallybark.com/>
# Project: https://github.com/landonb/waffle-batter#ðŸ¥ž
# License: MIT

# Copyright (c) Â© 2021-2021 Landon Bouma. All Rights Reserved.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# *** USAGE: Restrict this script to specific projects.

# YOU: Specify projects from your ~/.bashrc.
#
# - Suppose you have three projects that use Husky and have pre-push hooks.
#   You might include something like this in your user's startup scripts:
#
#     HUSKYRC_PRE_PUSH_PATHS=""
#     HUSKYRC_PRE_PUSH_PATHS="${HUSKYRC_PRE_PUSH_PATHS}\|/Users/myuser/git-smart"
#     HUSKYRC_PRE_PUSH_PATHS="${HUSKYRC_PRE_PUSH_PATHS}\|/Users/myuser/client/project/foo"
#     HUSKYRC_PRE_PUSH_PATHS="${HUSKYRC_PRE_PUSH_PATHS}\|/some/other/path"
#     export HUSKYRC_PRE_PUSH_PATHS

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# *** See also:
#
#   HUSKY_SKIP_HOOKS=1 git push ...
#
# if you just want to skip hooks.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

USER_HUSKY_RC_SKIP_INDICATOR="${HOME}/.huskyrc-no-pre-push"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# (lb): This is my version of grafting private hooks onto arbitrary
# branches from certain projects whose hooks I've disabled using an
# includeIf to include commit-no-verify.gitconfig from git-smart.
# - The use case is that I rebase a lot, and some projects' teams
#   squash-merge, so it doesn't matter if intermediate commits don't
#   pass checks -- also that running checks usually takes tens of
#   seconds per commit, and I'm impatient.
# - Currently, I only care about JavaScript projects that use husky
#   to run jest and eslint, and husky sources ~/.huskyrc before
#   running hooks. Furthermore, this script runs regardless of if
#   there are actually any hooks to run (beyond husky, which is
#   technically part of the hook (from Git's perspective), but not
#   really (from the developer's perspective) as husky is like a
#   meta hook, I suppose.
# - Note husky only runs when a hook runs, so, e.g.,
#   `git push --help` would not cause husky to run.
# - Also note that husky runs as a side-effect of Git, e.g.,
#   `git push remote branch` runs pre-push hook (and sources
#   this file first), but you can also runs hooks directly,
#   e.g., `cd ${working_dir} && .git/hooks/pre-commit`.

# A little more *Why*:
# - I've disabled pre-commit checks to make it easier to develop.
#   - But I don't always remember to run checks before pushing,
#     so I'd like to use pre-push to run checks automatically.
# - I could use package.json to add a custom pre-push hook, but
#   if I didn't want to force that change on other developers,
#   I'd only want to add the hook on a commit I don't push (which
#   I do do -- I have a number of private commits in what I call
#   my charms branch that I rebase atop feature branches while
#   under development, that I keep off the front of what I push
#   to the organization remote).
#   - But I'd like the hook to work even when I don't have my
#     charms commits picked, hence this .huskyrc hack-around.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

run_my_check_on_git_push_for_pre_push_paths () {
  # You'll see
  #   $0=.git/hooks/pre-commit for pre-commit,
  # or
  #   $0=.git/hooks/prepare-commit-msg
  #   $1=.git/COMMIT_EDITMSG
  #   $2=message for prepare-commit-msg,
  # etc.
  if [ "$0" != ".git/hooks/pre-push" ]; then
    return
  fi

  # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

  local working_dir="$(readlink_f "$(pwd)")"
  # Aka "$(command git rev-parse --show-toplevel)".

  [ -n "${HUSKYRC_PRE_PUSH_PATHS}" ] || return

  local project_paths_re="^\(${HUSKYRC_PRE_PUSH_PATHS}\)$"

  if ! echo "${working_dir}" | grep "${HUSKYRC_PRE_PUSH_PATHS}" > /dev/null 2>&1; then
    return
  fi

  # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

  local disallowed=false

  test_git_override_push_run_hooks () {
    # Check a few things to ensure we probably want to do this.

    # Check #1: Did git-smart/lib/git_safe.sh tell us not to run?
    local touch_file="${USER_HUSKY_RC_SKIP_INDICATOR}"
    if [ -f "${touch_file}" ] && [ ! -s "${touch_file}" ]; then
      /bin/rm "${touch_file}"
      # _git_safe prints a message that we back it on up and overwrite.
      #      >&2 printf "%s\n" "I'm going to allow this."
      #                         Hopes deleted.llow this.
      >&2 printf "\x1b[1A%s\n" "Hopes deleted.          "
      return 1
    fi

    # Check #1: Does package.json exist in root of project?
    local package_json="${working_dir}/package.json"
    if [ ! -f "${package_json}" ]; then
      >&2 printf "%s\n" "Totally Unexpected: Where's package.json?"
      return 1
    fi

    # Check #2: Is jq installed, so that we can read package.json?
    if ! type jq > /dev/null 2>&1; then
      >&2 printf "%s\n" "echo { \"You're\": \"So close, but you've got no\" } | \`jq\`"
      return 1
    fi

    # Check #3: Using jq, does the project define a pre-commit husky hook,
    # but not a pre-push husky hook?
    local husky_pre_commit husky_pre_push
    husky_pre_commit="$(jq -r '.husky.hooks."pre-commit" | select (.!=null)' "${package_json}")"
    husky_pre_push="$(jq -r '.husky.hooks."pre-push" | select (.!=null)' "${package_json}")"
    if [ -z "${husky_pre_commit}" ] || [ -n "${husky_pre_push}" ]; then
      # There's no pre-commit hook (that we could call);
      # or there's a pre-push already hooked.
      >&2 printf "%s\n" "Either pre-commit nor not pre-push, who knew."
      return 1
    fi

    return 0
  }

  git_override_push_check_deps () {
    node_verify_bin () {
      local bin_file="$1"
      if [ ! -x "${working_dir}/node_modules/.bin/${bin_file}" ]; then
        >&2 printf "%s\n" "ERROR: No ${bin_file} (or not executable)"
        return 1
      fi

      return 0
    }

    node_verify_bin "jest" &&
    node_verify_bin "eslint" &&
    return 0 || return 1
  }

  git_override_push_run_checks () {
    local checks_failed=false

    # This is like the default husky pre-commit hook (npm run test)
    # but we'll add --bail to fail quicker, and we'll lint first, too.

    # Note that warnings won't fail the lint check, but they'll generate
    # output -- and currently (2021-01-13) none of the projects I'm on
    # generate warnings -- so consider any output as a failure indicator.
    local fail_on_warnings=false
    if ! ${fail_on_warnings}; then
      ! ${checks_failed} &&
        npm run lint ||
          checks_failed=true
    else
      ! ${checks_failed} &&
        [ -z "$(npm run lint)" ] ||
          checks_failed=true
    fi

    ! ${checks_failed} &&
      npm test -- --bail --no-coverage ||
        checks_failed=true

    if ${checks_failed}; then
      >&2 printf "%s\n" "push came to shove and we all lost"
      exit 1
    fi
  }

  if ! test_git_override_push_run_hooks "$@"; then
    return
  fi

  git_override_push_check_deps &&
  git_override_push_run_checks
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  if [ "$1" == "--source" ]; then
    # Being called by _git_safe (git-smart/lib/git_safe.sh).
    export USER_HUSKY_RC_SKIP_INDICATOR
  else
    # Being called by husky-run.
    run_my_check_on_git_push_for_pre_push_paths "$@"
  fi
}

if [ "$0" != "${BASH_SOURCE[0]}" ]; then
  # Being sourced.
  main "$@"
fi
unset -f main

